#!/usr/bin/env python3
"""
Verify base cases up to N_base by enumerating all graphs in Q up to N_base
and checking Hamiltonicity using the repo solver.

Primary mode:
  - reads artifacts/Q_upto_nmax.graph6 generated by src/enumerate_Q_upto.py

Optional mode:
  - can call geng directly (same as enumerator) if artifact is missing.

Outputs a short report and fails if any base-case graph is non-Hamiltonian.
"""

from __future__ import annotations
import argparse
import os
import shutil
import subprocess
from typing import Dict, List, Iterable

import networkx as nx

import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

try:
    from src.barnette_proof import EmbeddedGraph, find_hamiltonian_cycle
except ImportError:
    # If src is not a package, try direct import if in path
    from barnette_proof import EmbeddedGraph, find_hamiltonian_cycle


def graph6_lines(path: str) -> List[str]:
    with open(path, "r", encoding="utf-8") as f:
        return [ln.strip() for ln in f.read().splitlines() if ln.strip() and not ln.startswith(">")]


def run_geng_graph6(n: int, geng_bin: str = "geng") -> Iterable[str]:
    cmd = [geng_bin, "-c", "-b", "-d3", "-D3", str(n)]
    p = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    for line in p.stdout.splitlines():
        line = line.strip()
        if not line or line.startswith(">"):
            continue
        yield line


def nx_to_embedded(G: nx.Graph) -> EmbeddedGraph:
    ok, emb = nx.check_planarity(G)
    if not ok:
        raise ValueError("not planar")

    adj = {int(v): set(int(u) for u in G.neighbors(v)) for v in G.nodes()}
    rot = {int(v): [int(u) for u in emb.neighbors(v)] for v in G.nodes()}
    return EmbeddedGraph(adj, rot)


def is_3connected(G: nx.Graph) -> bool:
    return (G.number_of_nodes() >= 4) and (nx.node_connectivity(G) >= 3)


def is_planar(G: nx.Graph) -> bool:
    ok, _ = nx.check_planarity(G, counterexample=False)
    return bool(ok)


def in_Q(G: nx.Graph) -> bool:
    if any(d != 3 for _, d in G.degree()):
        return False
    if not nx.is_bipartite(G):
        return False
    if not is_planar(G):
        return False
    if not is_3connected(G):
        return False
    return True


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--nbase", type=int, default=14)
    ap.add_argument("--artifact", default="artifacts/Q_upto_nmax.graph6")
    ap.add_argument("--geng-bin", default="geng")
    ap.add_argument("--use-geng-if-missing", action="store_true")
    args = ap.parse_args()

    g6s: List[str] = []
    if os.path.exists(args.artifact):
        g6s = graph6_lines(args.artifact)
        print(f"[info] loaded {len(g6s)} graph6 lines from {args.artifact}")
    else:
        if not args.use_geng_if_missing:
            raise SystemExit(
                f"[error] missing artifact {args.artifact}. "
                "Run: python src/enumerate_Q_upto.py --nmax 14 --out artifacts/Q_upto_nmax.graph6\n"
                "Or rerun with --use-geng-if-missing."
            )
        if shutil.which(args.geng_bin) is None:
            raise SystemExit(f"[error] '{args.geng_bin}' not on PATH, cannot enumerate.")
        for n in range(4, args.nbase + 1):
            if n % 2 == 1:
                continue
            for g6 in run_geng_graph6(n, geng_bin=args.geng_bin):
                g6s.append(g6)

    # Filter to Q and <= nbase (defensive)
    Q_g6: List[str] = []
    for g6 in g6s:
        G = nx.from_graph6_bytes(g6.encode("ascii"))
        G = nx.convert_node_labels_to_integers(G, first_label=0, ordering="sorted")
        if G.number_of_nodes() <= args.nbase and in_Q(G):
            Q_g6.append(g6)

    # Now verify Hamiltonicity for each Q graph
    by_n: Dict[int, int] = {}
    for g6 in Q_g6:
        G = nx.from_graph6_bytes(g6.encode("ascii"))
        G = nx.convert_node_labels_to_integers(G, first_label=0, ordering="sorted")
        n = G.number_of_nodes()
        by_n[n] = by_n.get(n, 0) + 1

        EG = nx_to_embedded(G)
        C = find_hamiltonian_cycle(EG, debug=False)
        # Validate cycle uses all vertices (solver should already ensure this)
        C.validate_hamiltonian(EG)

    print(f"[ok] all base-case graphs in Q with n <= {args.nbase} are Hamiltonian.")
    for n in sorted(by_n):
        print(f"  n={n}: {by_n[n]} graphs")


if __name__ == "__main__":
    main()
